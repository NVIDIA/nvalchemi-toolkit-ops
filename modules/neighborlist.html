
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="../_static/favicon.ico" rel="icon" type="image/x-icon">
    <title>nvalchemiops.neighborlist: Neighbor Lists &#8212; ALCHEMI Toolkit-Ops 0.2.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/nvidia-sphinx-theme.css?v=b165022f" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../_static/documentation_options.js?v=95e61db4"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'modules/neighborlist';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="nvalchemiops.interactions.dispersion: Dispersion Corrections" href="dispersion.html" />
    <link rel="prev" title="API Reference" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/NVIDIA-Logo-V-ForScreen-ForLightBG.png" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../_static/NVIDIA-Logo-V-ForScreen-ForDarkBG.png" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">ALCHEMI Toolkit-Ops</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../userguide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../examples/index.html">
                        Examples Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../benchmarks/index.html">
                        Benchmarks
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="index.html">
                        API
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.github.com/NVIDIA/nvalchemi-toolkit-ops" title="Github" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">Github</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary" tabindex="0">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../userguide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../examples/index.html">
                        Examples Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../benchmarks/index.html">
                        Benchmarks
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="index.html">
                        API
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.github.com/NVIDIA/nvalchemi-toolkit-ops" title="Github" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">Github</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.neighborlist</span></code>: Neighbor Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="dispersion.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.interactions.dispersion</span></code>: Dispersion Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="electrostatics.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.interactions.electrostatics</span></code>: Electrostatic Interactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.math</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.types</span></code>: Utilities</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">API Reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-nvalchemiops.neighborlist">
<span id="nvalchemiops-neighborlist-neighbor-lists"></span><h1><a class="reference internal" href="#module-nvalchemiops.neighborlist" title="nvalchemiops.neighborlist"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.neighborlist</span></code></a>: Neighbor Lists<a class="headerlink" href="#module-nvalchemiops.neighborlist" title="Link to this heading">#</a></h1>
<section id="high-level-interface">
<h2>High-Level Interface<a class="headerlink" href="#high-level-interface" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.neighbor_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">neighbor_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/neighborlist.html#neighbor_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.neighbor_list" title="Link to this definition">#</a></dt>
<dd><p>Compute neighbor list using the appropriate method based on the provided parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Concatenated atomic coordinates for all systems in Cartesian space.
Each row represents one atom’s (x, y, z) position.
Must be wrapped into the unit cell if PBC is used.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Cutoff distance for neighbor detection in Cartesian units.
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em><em>, </em><em>optional</em>) – Cell matrix defining the simulation box.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.bool</em><em>, </em><em>optional</em>) – Periodic boundary condition flags for each dimension.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – System index for each atom.</p></li>
<li><p><strong>batch_ptr</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems + 1</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Cumulative atom counts defining system boundaries.</p></li>
<li><p><strong>cutoff2</strong> (<em>float</em><em>, </em><em>optional</em>) – Second cutoff distance for neighbor detection in Cartesian units.
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only store half of the neighbor relationships to avoid double counting.
Another half could be reconstructed by swapping source and target indices and inverting unit shifts.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrix with. Default is total_atoms.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>method</strong> (<em>str</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Method to use for neighbor list computation.
Choices: “naive”, “cell_list”, “batch_naive”, “batch_cell_list”, “naive_dual_cutoff”, “batch_naive_dual_cutoff”.
If None, a default method will be chosen based on the number of atoms.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Additional keyword arguments to pass to the method.</p>
<ul>
<li><dl class="simple">
<dt>max_neighbors: int, optional</dt><dd><p>Maximum number of neighbors per atom.
Can be provided to aid in allocation for both naive and cell list methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>max_neighbors2: int, optional</dt><dd><p>Maximum number of neighbors per atom within cutoff2.
Can be provided to aid in allocation for naive dual cutoff method.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>neighbor_matrix: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms, max_neighbors) for neighbor indices.
Can be provided to avoid reallocation for both naive and cell list methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>neighbor_matrix_shifts: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms, max_neighbors, 3) for shift vectors.
Can be provided to avoid reallocation for both naive and cell list methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>num_neighbors: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms,) for neighbor counts.
Can be provided to avoid reallocation for both naive and cell list methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>shift_range_per_dimension: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (1, 3) for shift range in each dimension.
Can be provided to avoid reallocation for naive methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>shift_offset: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (2,) for cumulative sum of number of shifts for each system.
Can be provided to avoid reallocation for naive methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>total_shifts: int, optional</dt><dd><p>Total number of shifts.
Can be provided to avoid reallocation for naive methods.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cells_per_dimension: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (3,) for number of cells in x, y, z directions.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>neighbor_search_radius: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (3,) for radius of neighboring cells to search in each dimension.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>atom_periodic_shifts: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms, 3) for periodic boundary crossings for each atom.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>atom_to_cell_mapping: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms, 3) for cell coordinates for each atom.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>atoms_per_cell_count: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (max_total_cells,) for number of atoms in each cell.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cell_atom_start_indices: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (max_total_cells,) for starting index in cell_atom_list for each cell.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cell_atom_list: torch.Tensor, optional</dt><dd><p>Pre-allocated tensor of shape (total_atoms,) for flattened list of atom indices organized by cell.
Can be provided to avoid reallocation for cell list construction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>max_atoms_per_system: int, optional</dt><dd><p>Maximum number of atoms per system.
Used in batch naive implementation with PBC. If not provided, it will be computed automaticaly.
Can be provided to avoid CUDA synchronization.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple depending on input parameters. The return pattern follows:</p>
<dl class="simple">
<dt><strong>Single cutoff:</strong></dt><dd><ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors,</span> <span class="pre">neighbor_matrix_shifts)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr,</span> <span class="pre">neighbor_list_shifts)</span></code></p></li>
</ul>
</dd>
<dt><strong>Dual cutoff:</strong></dt><dd><ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix_shifts1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2,</span> <span class="pre">neighbor_matrix_shifts2)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">neighbor_list_shifts1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2,</span> <span class="pre">neighbor_list_shifts2)</span></code></p></li>
</ul>
</dd>
</dl>
<p><strong>Components returned:</strong></p>
<ul>
<li><p><strong>neighbor_data</strong> (tensor): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix</span></code>
with shape (total_atoms, max_neighbors), dtype int32. Each row i contains
indices of atom i’s neighbors.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list</span></code> with shape
(2, num_pairs), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.</p></li>
</ul>
<p>CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data</strong> (tensor, optional): Periodic shift vectors, only when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts</span></code> with
shape (total_atoms, max_neighbors, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">unit_shifts</span></code> with shape</p></li>
</ul>
<p>(num_pairs, 3), dtype int32.</p>
</div></blockquote>
</li>
</ul>
<p>When <code class="docutils literal notranslate"><span class="pre">cutoff2</span></code> is provided, the pattern repeats for the second cutoff with interleaved
components (neighbor_data2, num_neighbor_data2, neighbor_shift_data2) appended to the tuple.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Single cutoff, matrix format, with PBC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nm</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">shifts</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
</pre></div>
</div>
<p>Single cutoff, list format, no PBC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nlist</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">return_neighbor_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Dual cutoff, matrix format, with PBC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nm1</span><span class="p">,</span> <span class="n">num1</span><span class="p">,</span> <span class="n">sh1</span><span class="p">,</span> <span class="n">nm2</span><span class="p">,</span> <span class="n">num2</span><span class="p">,</span> <span class="n">sh2</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pos</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">cutoff2</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.naive_neighbor_list" title="nvalchemiops.neighborlist.naive_neighbor_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">naive_neighbor_list</span></code></a></dt><dd><p>Direct access to naive O(N²) algorithm</p>
</dd>
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.cell_list" title="nvalchemiops.neighborlist.cell_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_list</span></code></a></dt><dd><p>Direct access to cell list O(N) algorithm</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
<section id="single-system-algorithms">
<h2>Single System Algorithms<a class="headerlink" href="#single-system-algorithms" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.naive_neighbor_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">naive_neighbor_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_range_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/naive.html#naive_neighbor_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.naive_neighbor_list" title="Link to this definition">#</a></dt>
<dd><p>Compute neighbor list using naive O(N^2) algorithm.</p>
<p>Identifies all atom pairs within a specified cutoff distance using a
brute-force pairwise distance calculation. Supports both non-periodic
and periodic boundary conditions.</p>
<p>For non-pbc systems, this function is torch compilable. For pbc systems,
precompute the shift vectors using compute_naive_num_shifts.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">nvalchemiops.neighborlist</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_naive_num_shifts</span>
<span class="o">&gt;&gt;</span> <span class="n">shift_range_per_dimension</span><span class="p">,</span> <span class="n">shift_offset</span><span class="p">,</span> <span class="n">total_shifts</span> <span class="o">=</span> <span class="n">compute_naive_num_shifts</span><span class="p">(</span>
<span class="o">...</span>     <span class="n">cell</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">pbc</span>
<span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em>) – Atomic coordinates in Cartesian space. Each row represents one atom’s
(x, y, z) position.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Cutoff distance for neighbor detection in Cartesian units.
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.bool</em><em>, </em><em>optional</em>) – Periodic boundary condition flags for each dimension.
True enables periodicity in that direction. Default is None (no PBC).</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em><em>, </em><em>optional</em>) – Cell matrices defining lattice vectors in Cartesian coordinates.
Required if pbc is provided. Default is None.</p></li>
<li><p><strong>max_neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom. Must be positive.
If exceeded, excess neighbors are ignored.
Must be provided if neighbor_matrix is not provided.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only store relationships where i &lt; j to avoid double counting.
If False, store all neighbor relationships symmetrically. Default is False.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrix with. Default is total_atoms.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Neighbor matrix to be filled. Pass in a pre-allocated tensor to avoid reallocation.
Must be provided if max_neighbors is not provided.</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Shift vectors for each neighbor relationship. Pass in a pre-allocated tensor to avoid reallocation.
Must be provided if max_neighbors is not provided.</p></li>
<li><p><strong>num_neighbors</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Number of neighbors found for each atom. Pass in a pre-allocated tensor to avoid reallocation.
Must be provided if max_neighbors is not provided.</p></li>
<li><p><strong>shift_range_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Shift range in each dimension for each system.
Pass in a pre-allocated tensor to avoid reallocation for pbc systems.</p></li>
<li><p><strong>shift_offset</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Cumulative sum of number of shifts for each system.
Pass in a pre-allocated tensor to avoid reallocation for pbc systems.</p></li>
<li><p><strong>total_shifts</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of shifts.
Pass in a pre-allocated tensor to avoid reallocation for pbc systems.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple depending on input parameters. The return pattern follows:</p>
<ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors,</span> <span class="pre">neighbor_matrix_shifts)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr,</span> <span class="pre">neighbor_list_shifts)</span></code></p></li>
</ul>
<p><strong>Components returned:</strong></p>
<ul>
<li><p><strong>neighbor_data</strong> (tensor): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix</span></code>
with shape (total_atoms, max_neighbors), dtype int32. Each row i contains
indices of atom i’s neighbors.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list</span></code> with shape
(2, num_pairs), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom. Always returned.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data</strong> (tensor, optional): Periodic shift vectors, only when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts</span></code> with
shape (total_atoms, max_neighbors, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">unit_shifts</span></code> with shape
(num_pairs, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage without periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span>  <span class="c1"># 100 atoms in 10x10x10 box</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_neighbors</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix</span><span class="p">,</span> <span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_neighbors</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">num_neighbors</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> total neighbor pairs&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>With periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span>  <span class="c1"># 10x10x10 cubic cell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>  <span class="c1"># Periodic in all directions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Return as neighbor list instead of matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_list</span><span class="p">,</span> <span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="p">,</span> <span class="n">return_neighbor_list</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">source_atoms</span><span class="p">,</span> <span class="n">target_atoms</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">neighbor_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Preallocate tensors for non-pbc systems:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">max_neighbors</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_neighbors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix_shifts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_neighbors</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">positions</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="p">,</span> <span class="n">neighbor_matrix</span><span class="o">=</span><span class="n">neighbor_matrix</span><span class="p">,</span> <span class="n">neighbor_matrix_shifts</span><span class="o">=</span><span class="n">neighbor_matrix_shifts</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Preallocate tensors for pbc systems:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shift_range_per_dimension</span><span class="p">,</span> <span class="n">shift_offset</span><span class="p">,</span> <span class="n">total_shifts</span> <span class="o">=</span> <span class="n">_compute_total_shifts</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">cell</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">pbc</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="p">,</span> <span class="n">shift_range_per_dimension</span><span class="o">=</span><span class="n">shift_range_per_dimension</span><span class="p">,</span> <span class="n">shift_offset</span><span class="o">=</span><span class="n">shift_offset</span><span class="p">,</span> <span class="n">total_shifts</span><span class="o">=</span><span class="n">total_shifts</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_neighbor_list</span></code></dt><dd><p>Batch version for multiple systems</p>
</dd>
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.naive_neighbor_list_dual_cutoff" title="nvalchemiops.neighborlist.naive_neighbor_list_dual_cutoff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">naive_neighbor_list_dual_cutoff</span></code></a></dt><dd><p>Version with two cutoff distances</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/cell_list.html#cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.cell_list" title="Link to this definition">#</a></dt>
<dd><p>Build complete neighbor matrix using spatial cell list acceleration.</p>
<p>High-level convenience function that automatically estimates memory requirements,
builds spatial cell list data structures, and queries them to produce a complete
neighbor matrix. Combines build_cell_list and query_cell_list operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Atomic coordinates in Cartesian space where total_atoms is the number of atoms.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrix defining the simulation box. Each row represents a
lattice vector in Cartesian coordinates.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Flags indicating periodic boundary conditions in x, y, z directions.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Maximum distance for neighbor search.</p></li>
<li><p><strong>max_neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom. If not provided, will be estimated automatically.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only fill half of the neighbor matrix. Default is True.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrix with. Default is -1.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Pre-allocated tensor of shape (total_atoms, max_neighbors) for neighbor indices.
If None, allocated internally.</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Pre-allocated tensor of shape (total_atoms, max_neighbors, 3) for shift vectors.
If None, allocated internally.</p></li>
<li><p><strong>num_neighbors</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Pre-allocated tensor of shape (total_atoms,) for neighbor counts.
If None, allocated internally.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of cells in x, y, z directions.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Radius of neighboring cells to search in each dimension.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Cell coordinates for each atom.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting index in cell_atom_list for each cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Flattened list of atom indices organized by cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple depending on input parameters. The return pattern follows:</p>
<ul class="simple">
<li><p>Matrix format (default): <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors,</span> <span class="pre">neighbor_matrix_shifts)</span></code></p></li>
<li><p>List format (return_neighbor_list=True): <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr,</span> <span class="pre">neighbor_list_shifts)</span></code></p></li>
</ul>
<p><strong>Components returned:</strong></p>
<ul>
<li><p><strong>neighbor_data</strong> (tensor): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix</span></code>
with shape (total_atoms, max_neighbors), dtype int32. Each row i contains
indices of atom i’s neighbors, padded with fill_value.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list</span></code> with shape
(2, num_pairs), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data</strong> (tensor, optional): Periodic shift vectors for each neighbor,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code> and only returned when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts</span></code> with
shape (total_atoms, max_neighbors, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">unit_shifts</span></code> with shape
(num_pairs, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This is the main user-facing API for neighbor list construction</p></li>
<li><p>Uses automatic memory allocation estimation for torch.compile compatibility</p></li>
<li><p>For advanced users who want to cache cell lists, use build_cell_list and query_cell_list separately</p></li>
<li><p>Returns appropriate empty tensors for systems with &lt;= 1 atom or cutoff &lt;= 0</p></li>
</ul>
</dd></dl>

</section>
<section id="cell-list-sub-algorithms">
<h2>Cell List (Sub-)Algorithms<a class="headerlink" href="#cell-list-sub-algorithms" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.build_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">build_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/cell_list.html#build_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.build_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Build spatial cell list with fixed allocation sizes for torch.compile compatibility.</p>
<p>Constructs a spatial decomposition data structure for efficient neighbor searching.
Uses fixed-size memory allocations to prevent dynamic tensor creation that would
cause graph breaks in torch.compile. Returns individual tensor components rather
than a structured object for custom operator compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Atomic coordinates in Cartesian space where total_atoms is the number of atoms.
Must be float32, float64, or float16 dtype.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrix defining the simulation box. Each row represents a
lattice vector in Cartesian coordinates. Must match positions dtype.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=bool</em>) – Flags indicating periodic boundary conditions in x, y, z directions.
True enables PBC, False disables it for that dimension.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Maximum distance for neighbor search. Determines minimum cell size.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Number of cells created in x, y, z directions.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Shifts to search in each dimension.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Periodic boundary crossings for each atom.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: 3D cell coordinates assigned to each atom.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Number of atoms in each cell. Only first ‘total_cells’ entries are valid.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Starting index in cell_atom_list for each cell’s atoms.</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Flattened list of atom indices organized by cell. Use with start_indices
to extract atoms for each cell.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is torch.compile compatible and uses only static tensor shapes</p></li>
<li><p>Memory usage is determined by max_total_cells * max_atoms_per_cell</p></li>
<li><p>For optimal performance, use estimates from estimate_cell_list_sizes()</p></li>
<li><p>Cell list must be rebuilt when atoms move between cells or PBC/cell changes</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.query_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">query_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/cell_list.html#query_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.query_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Query spatial cell list to build neighbor matrix with distance constraints.</p>
<p>Uses pre-built cell list data structures to efficiently find all atom pairs
within the specified cutoff distance. Handles periodic boundary conditions
and returns neighbor matrix format.</p>
<p>This function is torch compilable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Atomic coordinates in Cartesian space.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrix for periodic boundary coordinate shifts.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Maximum distance for considering atoms as neighbors.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of cells in x, y, z directions from build_cell_list.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom from build_cell_list.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Shifts to search from build_cell_list.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – 3D cell coordinates for each atom from build_cell_list.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell from build_cell_list.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting index in cell_atom_list for each cell from build_cell_list.</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Flattened list of atom indices organized by cell from build_cell_list.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Neighbor matrix to be filled with neighbor atom indices.
Must be pre-allocated.</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Matrix storing shift vectors for each neighbor relationship.
Must be pre-allocated.</p></li>
<li><p><strong>num_neighbors</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Number of neighbors found for each atom.
Must be pre-allocated.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>This function modifies the input tensors in-place:</p>
<ul class="simple">
<li><p>neighbor_matrix : Filled with neighbor atom indices</p></li>
<li><p>neighbor_matrix_shifts : Filled with corresponding shift vectors</p></li>
<li><p>num_neighbors : Updated with neighbor counts per atom</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="batch-processing-algorithms">
<h2>Batch Processing Algorithms<a class="headerlink" href="#batch-processing-algorithms" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.batch_naive_neighbor_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">batch_naive_neighbor_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_range_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_atoms_per_system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_naive.html#batch_naive_neighbor_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list" title="Link to this definition">#</a></dt>
<dd><p>Compute batch neighbor matrix using naive O(N^2) algorithm.</p>
<p>Identifies all atom pairs within a specified cutoff distance for multiple
systems processed in a batch. Each system is processed independently,
supporting both non-periodic and periodic boundary conditions.</p>
<p>For efficiency, this function supports in-place modification of the pre-allocated tensors.
If not provided, the resulting tensors will be allocated.
This function does not introduce CUDA graph breaks for non-PBC systems.
For PBC systems, pre-compute unit shifts to avoid CUDA graph breaks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">nvalchemiops.neighborlist</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_naive_num_shifts</span>
<span class="o">&gt;&gt;</span> <span class="n">shift_range_per_dimension</span><span class="p">,</span> <span class="n">shift_offset</span><span class="p">,</span> <span class="n">total_shifts</span> <span class="o">=</span> <span class="n">compute_naive_num_shifts</span><span class="p">(</span>
<span class="o">...</span>     <span class="n">cell</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">pbc</span>
<span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em>) – Concatenated atomic coordinates for all systems in Cartesian space.
Each row represents one atom’s (x, y, z) position.
Must be wrapped into the unit cell if PBC is used.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Cutoff distance for neighbor detection in Cartesian units.
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – System index for each atom. Atoms with the same index belong to
the same system and can be neighbors. Must be in sorted order.
If not provided, assumes all atoms belong to a single system.</p></li>
<li><p><strong>batch_ptr</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems + 1</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Cumulative atom counts defining system boundaries.
System i contains atoms from batch_ptr[i] to batch_ptr[i+1]-1.
If not provided and batch_idx is provided, it will be computed automatically.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.bool</em><em>, </em><em>optional</em>) – Periodic boundary condition flags for each dimension of each system.
True enables periodicity in that direction. Default is None (no PBC).</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em><em>, </em><em>optional</em>) – Cell matrices defining lattice vectors in Cartesian coordinates.
Required if pbc is provided. Default is None.</p></li>
<li><p><strong>max_neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom. Must be positive.
If exceeded, excess neighbors are ignored.
Must be provided if neighbor_matrix is not provided.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only store half of the neighbor relationships to avoid double counting.
Another half could be reconstructed by swapping source and target indices and inverting unit shifts.
If False, store all neighbor relationships. Default is False.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrix with. Default is total_atoms.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the neighbor matrix.
Must be provided if max_neighbors is not provided.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the shift vectors of the neighbor matrix.
Must be provided if max_neighbors is not provided and pbc is not None.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>num_neighbors</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the number of neighbors in the neighbor matrix.
Must be provided if max_neighbors is not provided.</p></li>
<li><p><strong>shift_range_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the shift range in each dimension for each system.</p></li>
<li><p><strong>shift_offset</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems + 1</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the cumulative sum of number of shifts for each system.</p></li>
<li><p><strong>total_shifts</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of shifts.
Pass in to avoid reallocation for pbc systems.</p></li>
<li><p><strong>max_atoms_per_system</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of atoms per system.
If not provided, it will be computed automaticaly. Can be provided to avoid CUDA synchronization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple depending on input parameters. The return pattern follows:</p>
<ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors,</span> <span class="pre">neighbor_matrix_shifts)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr,</span> <span class="pre">neighbor_list_shifts)</span></code></p></li>
</ul>
<p><strong>Components returned:</strong></p>
<ul>
<li><p><strong>neighbor_data</strong> (tensor): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix</span></code>
with shape (total_atoms, max_neighbors), dtype int32. Each row i contains
indices of atom i’s neighbors.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list</span></code> with shape
(2, num_pairs), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data</strong> (tensor, optional): Periodic shift vectors, only when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts</span></code> with
shape (total_atoms, max_neighbors, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">unit_shifts</span></code> with shape
(num_pairs, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic batch processing without periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch with 2 systems: 50 and 30 atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">30</span><span class="p">)])</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_ptr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_neighbors</span> <span class="o">=</span> <span class="mi">40</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">batch_naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">batch_ptr</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="o">=</span><span class="n">max_neighbors</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># neighbor_matrix_shifts will be empty tensor for non-PBC systems</span>
</pre></div>
</div>
<p>With periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Different cells for each system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.0</span><span class="p">,</span>  <span class="c1"># System 0: 5x5x5 cubic cell</span>
<span class="gp">... </span>    <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span>   <span class="c1"># System 1: 8x8x8 cubic cell</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">,</span> <span class="n">neighbor_matrix_shifts</span> <span class="o">=</span> <span class="n">batch_naive_neighbor_list</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">batch_ptr</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">max_neighbors</span><span class="o">=</span><span class="n">max_neighbors</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.naive_neighbor_list" title="nvalchemiops.neighborlist.naive_neighbor_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">naive_neighbor_list</span></code></a></dt><dd><p>Single system version</p>
</dd>
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list_dual_cutoff" title="nvalchemiops.neighborlist.batch_naive_neighbor_list_dual_cutoff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_naive_neighbor_list_dual_cutoff</span></code></a></dt><dd><p>Version with two cutoff distances</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.batch_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">batch_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_cell_list.html#batch_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.batch_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Build complete batch neighbor matrices using spatial cell list acceleration.</p>
<p>High-level convenience function that processes multiple systems
simultaneously. Automatically estimates memory requirements, builds batch
spatial cell list data structures, and queries them to produce complete
neighbor matrices for all systems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Concatenated atomic coordinates for all systems in the batch.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Neighbor search cutoff distance.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrices for each system in the batch.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags for each system and dimension.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – System index for each atom.</p></li>
<li><p><strong>max_neighbors</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom. If None, automatically estimated.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, only fill half of the neighbor matrix.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to use for padding empty neighbor slots in the matrix. Default is total_atoms.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default=False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of cells in x, y, z directions.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Radius of neighboring cells to search in each dimension.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Cell coordinates for each atom.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting index in cell_atom_list for each cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Flattened list of atom indices organized by cell.
Pass a pre-allocated tensor to avoid reallocation for cell list construction.
If None, allocated internally to build the cell list.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>Tensor</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>Tensor</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>num_neighbors</strong> (<em>Tensor</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple depending on input parameters. The return pattern follows:</p>
<ul class="simple">
<li><p>Matrix format (default): <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix,</span> <span class="pre">num_neighbors,</span> <span class="pre">neighbor_matrix_shifts)</span></code></p></li>
<li><p>List format (return_neighbor_list=True): <code class="docutils literal notranslate"><span class="pre">(neighbor_list,</span> <span class="pre">neighbor_ptr,</span> <span class="pre">neighbor_list_shifts)</span></code></p></li>
</ul>
<p><strong>Components returned:</strong></p>
<ul>
<li><p><strong>neighbor_data</strong> (tensor): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix</span></code>
with shape (total_atoms, max_neighbors), dtype int32. Each row i contains
indices of atom i’s neighbors, padded with fill_value.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list</span></code> with shape
(2, num_pairs), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data</strong> (tensor): Periodic shift vectors for each neighbor,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts</span></code> with
shape (total_atoms, max_neighbors, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list_shifts</span></code> with shape
(num_pairs, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This is the main user-facing API for batch neighbor list construction</p></li>
<li><p>Uses automatic memory allocation estimation for torch.compile compatibility</p></li>
<li><p>Efficiently processes systems with different sizes, cells, PBC, and cutoffs</p></li>
<li><p>For advanced users who want to cache cell lists, use build_batch_cell_list and query_batch_cell_list separately</p></li>
<li><p>Returns empty tensors for empty batches</p></li>
</ul>
</dd></dl>

</section>
<section id="batch-cell-list-sub-algorithms">
<h2>Batch Cell List (Sub-)Algorithms<a class="headerlink" href="#batch-cell-list-sub-algorithms" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.batch_build_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">batch_build_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_cell_list.html#batch_build_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.batch_build_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Build batch spatial cell lists with fixed allocation sizes for torch.compile compatibility.</p>
<p>Constructs a batch spatial cell list with fixed allocation sizes for torch.compile compatibility.
Uses fixed-size memory allocations to prevent dynamic tensor creation that would
cause graph breaks in torch.compile. Returns individual tensor components rather
than a structured object for custom operator compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Concatenated atomic coordinates for all systems in the batch.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Neighbor search cutoff distance.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrices for each system in the batch.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags for each system and dimension.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – System index for each atom.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of cells in x, y, z directions for each system.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Radius of neighboring cells to search for each system.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom across all systems.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – 3D cell coordinates assigned to each atom across all systems.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell across all systems.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting index in global cell arrays for each system (CSR format).</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Flattened list of atom indices organized by cell across all systems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>This function modifies the input tensors in-place.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.batch_query_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">batch_query_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_cell_list.html#batch_query_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.batch_query_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Query batch spatial cell lists to build neighbor matrices for multiple systems.</p>
<p>Uses pre-built cell list data structures to efficiently find all atom pairs
within the specified cutoff distance. Handles periodic boundary conditions
and returns neighbor matrix format.</p>
<p>This function is torch compilable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Concatenated atomic coordinates for all systems in the batch.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrices for each system in the batch.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags for each system and dimension.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Neighbor search cutoff distance.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Index of the system for each atom.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of cells in x, y, z directions for each system.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Radius of neighboring cells to search for each system.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – 3D cell coordinates for each atom.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell across all systems.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>max_total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting index in batch_cell_atom_list for each cell.</p></li>
<li><p><strong>neighbor_matrix</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Neighbor matrix to be filled with neighbor atom indices.
Must be pre-allocated.</p></li>
<li><p><strong>neighbor_matrix_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Matrix storing shift vectors for each neighbor relationship.
Must be pre-allocated.</p></li>
<li><p><strong>num_neighbors</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – OUTPUT: Number of neighbors found for each atom.
Must be pre-allocated.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em>) – If True, only store half of the neighbor relationships (i &lt; j).</p></li>
<li><p><strong>cell_atom_list</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>This function modifies the input tensors in-place:</p>
<ul class="simple">
<li><p>neighbor_matrix : Filled with neighbor atom indices</p></li>
<li><p>neighbor_matrix_shifts : Filled with corresponding shift vectors</p></li>
<li><p>num_neighbors : Updated with neighbor counts per atom</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="dual-cutoff-algorithms">
<h2>Dual Cutoff Algorithms<a class="headerlink" href="#dual-cutoff-algorithms" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.naive_neighbor_list_dual_cutoff">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">naive_neighbor_list_dual_cutoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_range_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/naive_dual_cutoff.html#naive_neighbor_list_dual_cutoff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.naive_neighbor_list_dual_cutoff" title="Link to this definition">#</a></dt>
<dd><p>Compute neighbor list using naive O(N^2) algorithm with dual cutoffs.</p>
<p>Identifies all atom pairs within two different cutoff distances using a
single brute-force pairwise distance calculation. This is more efficient
than running two separate neighbor calculations when both neighbor lists are needed.
Supports both non-periodic and periodic boundary conditions.</p>
<p>For non-pbc systems, this function is torch compilable. For pbc systems,
precompute the shift vectors using _compute_total_shifts to maintain torch compilability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em>) – Atomic coordinates in Cartesian space. Each row represents one atom’s
(x, y, z) position.</p></li>
<li><p><strong>cutoff1</strong> (<em>float</em>) – First cutoff distance in Cartesian units (typically the smaller cutoff).
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>cutoff2</strong> (<em>float</em>) – Second cutoff distance in Cartesian units (typically the larger cutoff).
Must be positive and should be &gt;= cutoff1 for optimal performance.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.bool</em><em>, </em><em>optional</em>) – Periodic boundary condition flags for each dimension.
True enables periodicity in that direction. Default is None (no PBC).</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em><em>, </em><em>optional</em>) – Cell matrices defining lattice vectors in Cartesian coordinates.
Required if pbc is provided. Default is None.</p></li>
<li><p><strong>max_neighbors1</strong> (<em>int</em>) – Maximum number of neighbors per atom for the first neighbor matrix.
Must be positive. If exceeded, excess neighbors are ignored.</p></li>
<li><p><strong>max_neighbors2</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom for the second neighbor matrix.
If None, defaults to max_neighbors1. Must be positive if provided.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only store relationships where i &lt; j to avoid double counting.
If False, store all neighbor relationships symmetrically. Default is False.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrices with. Default is total_atoms.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>neighbor_matrix1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors1</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – First neighbor matrix for cutoff1 to be filled with fill_value.
Must be pre-allocated. Entries are filled with fill_value.</p></li>
<li><p><strong>neighbor_matrix2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors2</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Second neighbor matrix for cutoff2 to be filled with fill_value.
Must be pre-allocated. Entries are filled with fill_value.</p></li>
<li><p><strong>neighbor_matrix_shifts1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Shift vectors for each neighbor relationship in the first matrix.
Must be pre-allocated. Entries are filled with shift vectors.</p></li>
<li><p><strong>neighbor_matrix_shifts2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors2</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Shift vectors for each neighbor relationship in the second matrix.
Must be pre-allocated. Entries are filled with shift vectors.</p></li>
<li><p><strong>num_neighbors1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Number of neighbors found for each atom within cutoff1.
Must be pre-allocated. Updated in-place with actual neighbor counts.</p></li>
<li><p><strong>num_neighbors2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Number of neighbors found for each atom within cutoff2.
Must be pre-allocated. Updated in-place with actual neighbor counts.</p></li>
<li><p><strong>shift_range_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Shift range in each dimension for each system.</p></li>
<li><p><strong>shift_offset</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>2</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Cumulative sum of number of shifts for each system.</p></li>
<li><p><strong>total_shifts</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of shifts.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple with interleaved results for cutoff1 and cutoff2. The return pattern follows:</p>
<ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix_shifts1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2,</span> <span class="pre">neighbor_matrix_shifts2)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">neighbor_list_shifts1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2,</span> <span class="pre">neighbor_list_shifts2)</span></code></p></li>
</ul>
<p><strong>Components returned (interleaved for each cutoff):</strong></p>
<ul>
<li><p><strong>neighbor_data1, neighbor_data2</strong> (tensors): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_matrix2</span></code>
with shapes (total_atoms, max_neighbors1) and (total_atoms, max_neighbors2), dtype int32.
Each row i contains indices of atom i’s neighbors within the respective cutoff.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_list2</span></code> with shapes
(2, num_pairs1) and (2, num_pairs2), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data1, num_neighbor_data2</strong> (tensors): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors1</span></code> and <code class="docutils literal notranslate"><span class="pre">num_neighbors2</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom within cutoff1 and cutoff2 respectively.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_ptr2</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data1, neighbor_shift_data2</strong> (tensors, optional): Periodic shift vectors, only when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts2</span></code> with
shape (total_atoms, max_neighbors1, 3) and (total_atoms, max_neighbors2, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">unit_shifts1</span></code> and <code class="docutils literal notranslate"><span class="pre">unit_shifts2</span></code> with shapes
(num_pairs1, 3) and (num_pairs2, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage with dual cutoffs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span>  <span class="c1"># 100 atoms in 10x10x10 box</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff1</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># Short-range interactions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff2</span> <span class="o">=</span> <span class="mf">4.0</span>  <span class="c1"># Long-range interactions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">naive_neighbor_list_dual_cutoff</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">,</span> <span class="n">cutoff2</span><span class="p">,</span> <span class="n">max_neighbors1</span><span class="o">=</span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span><span class="o">=</span><span class="n">max_neighbors2</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neighbor_matrix1</span><span class="p">,</span> <span class="n">num_neighbors1</span><span class="p">,</span> <span class="n">neighbor_matrix2</span><span class="p">,</span> <span class="n">num_neighbors2</span> <span class="o">=</span> <span class="n">results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Short-range pairs: </span><span class="si">{</span><span class="n">num_neighbors1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Long-range pairs: </span><span class="si">{</span><span class="n">num_neighbors2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>With periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.0</span>  <span class="c1"># 10x10x10 cubic cell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>  <span class="c1"># Periodic in all directions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">naive_neighbor_list_dual_cutoff</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">,</span> <span class="n">cutoff2</span><span class="p">,</span> <span class="n">max_neighbors1</span><span class="o">=</span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span><span class="o">=</span><span class="n">max_neighbors2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">neighbor_matrix1</span><span class="p">,</span> <span class="n">num_neighbors1</span><span class="p">,</span> <span class="n">shifts1</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">neighbor_matrix2</span><span class="p">,</span> <span class="n">num_neighbors2</span><span class="p">,</span> <span class="n">shifts2</span><span class="p">)</span> <span class="o">=</span> <span class="n">results</span>
</pre></div>
</div>
<p>Preallocate tensors for non-pbc systems:
&gt;&gt;&gt; max_neighbors1 = 100
&gt;&gt;&gt; neighbor_matrix1 = torch.zeros((positions.shape[0], max_neighbors1), dtype=torch.int32, device=positions.device)
&gt;&gt;&gt; neighbor_matrix2 = torch.zeros((positions.shape[0], max_neighbors2), dtype=torch.int32, device=positions.device)
&gt;&gt;&gt; num_neighbors1 = torch.zeros(positions.shape[0], dtype=torch.int32, device=positions.device)
&gt;&gt;&gt; num_neighbors2 = torch.zeros(positions.shape[0], dtype=torch.int32, device=positions.device)
&gt;&gt;&gt; naive_neighbor_list_dual_cutoff(
…     positions, cutoff1, cutoff2,
…     max_neighbors1=max_neighbors1, max_neighbors2=max_neighbors2,
…     neighbor_matrix1=neighbor_matrix1, neighbor_matrix2=neighbor_matrix2,
…     num_neighbors1=num_neighbors1, num_neighbors2=num_neighbors2
… )
&gt;&gt;&gt; print(f”Short-range pairs: {num_neighbors1.sum()}”)
&gt;&gt;&gt; print(f”Long-range pairs: {num_neighbors2.sum()}”)</p>
<p>Preallocate tensors for pbc systems:
&gt;&gt;&gt; shift_range_per_dimension, shift_offset, total_shifts = compute_naive_num_shifts(
…     cell, cutoff1, pbc
… )
&gt;&gt;&gt; naive_neighbor_list_dual_cutoff(
…     positions, cutoff1, cutoff2,
…     max_neighbors1=max_neighbors1, max_neighbors2=max_neighbors2,
…     shift_range_per_dimension=shift_range_per_dimension, shift_offset=shift_offset, total_shifts=total_shifts
…     neighbor_matrix1=neighbor_matrix1, neighbor_matrix2=neighbor_matrix2,
…     num_neighbors1=num_neighbors1, num_neighbors2=num_neighbors2
… )
&gt;&gt;&gt; print(f”Short-range pairs: {num_neighbors1.sum()}”)
&gt;&gt;&gt; print(f”Long-range pairs: {num_neighbors2.sum()}”)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.naive_neighbor_list" title="nvalchemiops.neighborlist.naive_neighbor_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">naive_neighbor_list</span></code></a></dt><dd><p>Single cutoff version</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_neighbor_list_dual_cutoff</span></code></dt><dd><p>Batch version for multiple systems</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.batch_naive_neighbor_list_dual_cutoff">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">batch_naive_neighbor_list_dual_cutoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_neighbors2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_neighbor_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_matrix_shifts2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neighbors2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_range_per_dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_atoms_per_system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_naive_dual_cutoff.html#batch_naive_neighbor_list_dual_cutoff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list_dual_cutoff" title="Link to this definition">#</a></dt>
<dd><p>Compute two batch neighbor matrices using dual cutoffs with naive O(N^2) algorithm.</p>
<p>Identifies all atom pairs within two different cutoff distances for multiple
systems processed in a batch. Each system is processed independently with
dual cutoffs, supporting both non-periodic and periodic boundary conditions.
This is more efficient than running batch neighbor calculations for each cutoff separately.</p>
<p>For efficiency, this function supports in-place modification of the pre-allocated tensors.
If not provided, the resulting tensors will be allocated.
This function does not introduce CUDA graph breaks for non-PBC systems.
For PBC systems, pre-compute unit shifts to avoid CUDA graph breaks:
<cite>shift_range_per_dimension, shift_offset, total_shifts = compute_naive_num_shifts(cell, cutoff2, pbc)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em>) – Concatenated atomic coordinates for all systems in Cartesian space.
Each row represents one atom’s (x, y, z) position.
Must be wrapped into the unit cell if PBC is used.</p></li>
<li><p><strong>cutoff1</strong> (<em>float</em>) – First (short range) cutoff distance in Cartesian units (typically the smaller cutoff).
Must be positive. Atoms within this distance are considered neighbors.</p></li>
<li><p><strong>cutoff2</strong> (<em>float</em>) – Second cutoff distance in Cartesian units (typically the larger cutoff).
Must be positive and be &gt;= cutoff1.</p></li>
<li><p><strong>batch_idx</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – System index for each atom. Atoms with the same index belong to
the same system and can be neighbors. Must be in sorted order.
If not provided, assumes all atoms belong to a single system.</p></li>
<li><p><strong>batch_ptr</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems + 1</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Cumulative atom counts defining system boundaries.
System i contains atoms from batch_ptr[i] to batch_ptr[i+1]-1.
If not provided and batch_idx is provided, it will be computed automatically.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.bool</em><em>, </em><em>optional</em>) – Periodic boundary condition flags for each dimension of each system.
True enables periodicity in that direction. Default is None (no PBC).</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.float32</em><em> or </em><em>torch.float64</em><em>, </em><em>optional</em>) – Cell matrices defining lattice vectors in Cartesian coordinates.
Required if pbc is provided. Default is None.</p></li>
<li><p><strong>max_neighbors1</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom for the first neighbor matrix.
Must be positive. If exceeded, excess neighbors are ignored.
Must be provided if neighbor_matrix1 is not provided.</p></li>
<li><p><strong>max_neighbors2</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of neighbors per atom for the second neighbor matrix.
Must be positive. If exceeded, excess neighbors are ignored.
Must be provided if neighbor_matrix2 is not provided.</p></li>
<li><p><strong>half_fill</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only store half of the neighbor relationships to avoid double counting.
Another half could be reconstructed by swapping source and target indices and inverting unit shifts.
If False, store all neighbor relationships. Default is False.</p></li>
<li><p><strong>fill_value</strong> (<em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Value to fill the neighbor matrices with. Default is total_atoms.</p></li>
<li><p><strong>return_neighbor_list</strong> (<em>bool</em><em>, </em><em>optional - default = False</em>) – If True, convert the neighbor matrix to a neighbor list (idx_i, idx_j) format by
creating a mask over the fill_value, which can incur a performance penalty.
We recommend using the neighbor matrix format,
and only convert to a neighbor list format if absolutely necessary.</p></li>
<li><p><strong>neighbor_matrix1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors1</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the first (short-range) neighbor matrix.
Must be provided if max_neighbors1 is not provided.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>neighbor_matrix2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors2</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the second (long-range) neighbor matrix.
Must be provided if max_neighbors2 is not provided.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>neighbor_matrix_shifts1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the shift vectors of the first (short-range) neighbor matrix.
Must be provided if max_neighbors1 is not provided and pbc is not None.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>neighbor_matrix_shifts2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>max_neighbors2</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the shift vectors of the second (long-range) neighbor matrix.
Must be provided if max_neighbors2 is not provided and pbc is not None.
If provided, return_neighbor_list must be False.</p></li>
<li><p><strong>num_neighbors1</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the number of neighbors in the first (short-range) neighbor matrix.
Must be provided if max_neighbors1 is not provided.</p></li>
<li><p><strong>num_neighbors2</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the number of neighbors in the second (long-range) neighbor matrix.
Must be provided if max_neighbors2 is not provided.</p></li>
<li><p><strong>shift_range_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the shift range in each dimension for each system for cutoff2.</p></li>
<li><p><strong>shift_offset</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems + 1</em><em>,</em><em>)</em><em>, </em><em>dtype=torch.int32</em><em>, </em><em>optional</em>) – Optional pre-allocated tensor for the cumulative sum of number of shifts for each system for cutoff2.</p></li>
<li><p><strong>total_shifts</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of shifts for cutoff2.
Pass in to avoid reallocation for pbc systems.</p></li>
<li><p><strong>max_atoms_per_system</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of atoms per system.
If not provided, it will be computed automaticaly.
Can be provided to avoid CUDA synchronization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – Variable-length tuple with interleaved results for cutoff1 and cutoff2. The return pattern follows:</p>
<ul class="simple">
<li><p>No PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2)</span></code></p></li>
<li><p>No PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2)</span></code></p></li>
<li><p>With PBC, matrix format: <code class="docutils literal notranslate"><span class="pre">(neighbor_matrix1,</span> <span class="pre">num_neighbors1,</span> <span class="pre">neighbor_matrix_shifts1,</span> <span class="pre">neighbor_matrix2,</span> <span class="pre">num_neighbors2,</span> <span class="pre">neighbor_matrix_shifts2)</span></code></p></li>
<li><p>With PBC, list format: <code class="docutils literal notranslate"><span class="pre">(neighbor_list1,</span> <span class="pre">neighbor_ptr1,</span> <span class="pre">shifts1,</span> <span class="pre">neighbor_list2,</span> <span class="pre">neighbor_ptr2,</span> <span class="pre">shifts2)</span></code></p></li>
</ul>
<p><strong>Components returned (interleaved for each cutoff):</strong></p>
<ul>
<li><p><strong>neighbor_data1, neighbor_data2</strong> (tensors): Neighbor indices, format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_matrix2</span></code>
with shapes (total_atoms, max_neighbors1) and (total_atoms, max_neighbors2), dtype int32.
Each row i contains indices of atom i’s neighbors within the respective cutoff.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_list2</span></code> with shapes
(2, num_pairs1) and (2, num_pairs2), dtype int32, in COO format [source_atoms, target_atoms].</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>num_neighbor_data1, num_neighbor_data2</strong> (tensor): Information about the number of neighbors for each atom,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">num_neighbors</span></code> with shape (total_atoms,), dtype int32.
Count of neighbors found for each atom.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_ptr</span></code> with shape (total_atoms + 1,), dtype int32.
CSR-style pointer arrays where <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">neighbor_ptr_data[i+1]</span></code> gives the range of
neighbors for atom i in the flattened neighbor list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>neighbor_shift_data1, neighbor_shift_data2</strong> (tensor): Periodic shift vectors for each neighbor,
format depends on <code class="docutils literal notranslate"><span class="pre">return_neighbor_list</span></code> and only returned when <code class="docutils literal notranslate"><span class="pre">pbc</span></code> is provided:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=False</span></code> (default): Returns <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_matrix_shifts2</span></code> with
shape (total_atoms, max_neighbors1, 3) and (total_atoms, max_neighbors2, 3), dtype int32.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">return_neighbor_list=True</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">neighbor_list_shifts1</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_list_shifts2</span></code> with shape
(num_pairs1, 3) and (num_pairs2, 3), dtype int32.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic batch processing with dual cutoffs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create batch with 2 systems: 50 and 30 atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">30</span><span class="p">)])</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_ptr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff1</span><span class="p">,</span> <span class="n">cutoff2</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span>  <span class="c1"># Short and long range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">neighbor_matrix1</span><span class="p">,</span> <span class="n">num_neighbors1</span><span class="p">,</span> <span class="n">neighbor_matrix2</span><span class="p">,</span> <span class="n">num_neighbors2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">batch_naive_neighbor_list_dual_cutoff</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">,</span> <span class="n">cutoff2</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">batch_ptr</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">max_neighbors1</span><span class="o">=</span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span><span class="o">=</span><span class="n">max_neighbors2</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># neighbor_matrix_shifts will be empty tensors for non-PBC systems</span>
</pre></div>
</div>
<p>With periodic boundary conditions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Different cells for each system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.0</span><span class="p">,</span>  <span class="c1"># System 0: 5x5x5 cubic cell</span>
<span class="gp">... </span>    <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mf">8.0</span>   <span class="c1"># System 1: 8x8x8 cubic cell</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">neighbor_matrix1</span><span class="p">,</span> <span class="n">num_neighbors1</span><span class="p">,</span> <span class="n">neighbor_matrix_shifts1</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">neighbor_matrix2</span><span class="p">,</span> <span class="n">num_neighbors2</span><span class="p">,</span> <span class="n">neighbor_matrix_shifts2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">batch_naive_neighbor_list_dual_cutoff</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">positions</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">,</span> <span class="n">cutoff2</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">batch_ptr</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">max_neighbors1</span><span class="o">=</span><span class="n">max_neighbors1</span><span class="p">,</span> <span class="n">max_neighbors2</span><span class="o">=</span><span class="n">max_neighbors2</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list" title="nvalchemiops.neighborlist.batch_naive_neighbor_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">batch_naive_neighbor_list</span></code></a></dt><dd><p>Single cutoff version</p>
</dd>
</dl>
</div>
</dd></dl>

</section>
<section id="rebuild-detection">
<h2>Rebuild Detection<a class="headerlink" href="#rebuild-detection" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.cell_list_needs_rebuild">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">cell_list_needs_rebuild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/rebuild_detection.html#cell_list_needs_rebuild"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.cell_list_needs_rebuild" title="Link to this definition">#</a></dt>
<dd><p>Detect if spatial cell list requires rebuilding due to atomic motion.</p>
<p>This torch.compile-compatible custom operator efficiently determines if any atoms
have moved between spatial cells since the last cell list construction. Uses GPU
acceleration with early termination for optimal performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Current atomic coordinates in Cartesian space.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – 3D cell coordinates for each atom from the existing cell list.
Typically obtained from build_cell_list.</p></li>
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of spatial cells in x, y, z directions.</p></li>
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrix for coordinate transformations.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags for x, y, z directions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rebuild_needed</strong> – True if any atom has moved to a different cell requiring rebuild.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, shape (1,), dtype=bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Currently only supports single system.</p></li>
<li><p>torch.compile compatible custom operation</p></li>
<li><p>Uses GPU kernels for parallel cell assignment computation</p></li>
<li><p>Early termination optimization stops computation once rebuild is detected</p></li>
<li><p>Handles periodic boundary conditions correctly</p></li>
<li><p>Returns tensor (not Python bool) for compilation compatibility</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.neighbor_list_needs_rebuild">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">neighbor_list_needs_rebuild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skin_distance_threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/rebuild_detection.html#neighbor_list_needs_rebuild"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.neighbor_list_needs_rebuild" title="Link to this definition">#</a></dt>
<dd><p>Detect if neighbor list requires rebuilding due to excessive atomic motion.</p>
<p>This torch.compile-compatible custom operator efficiently determines if any atoms
have moved beyond the skin distance since the neighbor list was last built. Uses
GPU acceleration with early termination for optimal performance in MD simulations.</p>
<p>The skin distance approach allows neighbor lists to remain valid even when atoms
move slightly, reducing the frequency of expensive neighbor list reconstructions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Atomic coordinates when the neighbor list was last constructed.</p></li>
<li><p><strong>current_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Current atomic coordinates to compare against reference.</p></li>
<li><p><strong>skin_distance_threshold</strong> (<em>float</em>) – Maximum allowed atomic displacement before neighbor list becomes invalid.
Typically set to (cutoff_radius - cutoff) / 2 for safety.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rebuild_needed</strong> – True if any atom has moved beyond skin distance requiring rebuild.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, shape (1,), dtype=bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Currently only supports single system.</p></li>
<li><p>torch.compile compatible custom operation</p></li>
<li><p>Uses GPU kernels for parallel displacement computation</p></li>
<li><p>Early termination optimization stops computation once rebuild is detected</p></li>
<li><p>Displacement calculation uses Euclidean distance</p></li>
<li><p>Returns tensor (not Python bool) for compilation compatibility</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.check_cell_list_rebuild_needed">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">check_cell_list_rebuild_needed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cells_per_dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_periodic_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_to_cell_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_per_cell_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_start_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_atom_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/rebuild_detection.html#check_cell_list_rebuild_needed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.check_cell_list_rebuild_needed" title="Link to this definition">#</a></dt>
<dd><p>Determine if spatial cell list requires rebuilding based on atomic motion.</p>
<p>This high-level function provides a comprehensive check to determine if a spatial
cell list needs to be reconstructed due to atomic movement. It uses GPU acceleration
to efficiently detect when atoms have moved between spatial cells.</p>
<p>The function primarily checks if any atoms have moved to different spatial cells
since the cell list was last built by comparing current positions against the
stored cell assignments from the existing cell list.</p>
<p>This function is not torch.compile compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cells_per_dimension</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of spatial cells in x, y, z directions from existing cell list.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Search radius for neighboring cells in each dimension from existing cell list.</p></li>
<li><p><strong>atom_periodic_shifts</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – Periodic boundary crossings for each atom from existing cell list.</p></li>
<li><p><strong>atom_to_cell_mapping</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=int32</em>) – 3D cell coordinates assigned to each atom from existing cell list.
This is the key tensor used for comparison with current positions.</p></li>
<li><p><strong>atoms_per_cell_count</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Number of atoms in each cell from existing cell list.</p></li>
<li><p><strong>cell_atom_start_indices</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_cells</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Starting indices for each cell’s atom list from existing cell list.</p></li>
<li><p><strong>cell_atom_list</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>,</em><em>)</em><em>, </em><em>dtype=int32</em>) – Flattened atom indices organized by cell from existing cell list.</p></li>
<li><p><strong>current_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Current atomic coordinates to check against existing cell assignments.</p></li>
<li><p><strong>current_cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Current unit cell matrix for coordinate transformations.</p></li>
<li><p><strong>current_pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>dtype=bool</em>) – Current periodic boundary condition flags for x, y, z directions.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Neighbor search cutoff distance (currently unused, kept for API compatibility).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>needs_rebuild</strong> – True if any atom has moved to a different cell requiring cell list rebuild.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Currently only supports single system.</p></li>
<li><p>Uses GPU kernels for efficient parallel computation</p></li>
<li><p>Primary check: atomic motion between spatial cells</p></li>
<li><p>Early termination optimization for performance</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.check_neighbor_list_rebuild_needed">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">check_neighbor_list_rebuild_needed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skin_distance_threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/rebuild_detection.html#check_neighbor_list_rebuild_needed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.check_neighbor_list_rebuild_needed" title="Link to this definition">#</a></dt>
<dd><p>Determine if neighbor list requires rebuilding based on atomic motion.</p>
<p>This high-level function provides a convenient interface to check if a neighbor
list needs reconstruction due to excessive atomic movement. Uses the skin distance
approach to minimize unnecessary neighbor list rebuilds during MD simulations.</p>
<p>The skin distance technique allows atoms to move slightly without invalidating
the neighbor list, reducing computational overhead. When any atom moves beyond
the skin distance, the neighbor list must be rebuilt to maintain accuracy.</p>
<p>This function is not torch.compile compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Atomic coordinates when the neighbor list was last constructed.
Used as the reference point for displacement calculations.</p></li>
<li><p><strong>current_positions</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>total_atoms</em><em>, </em><em>3</em><em>)</em>) – Current atomic coordinates to compare against reference positions.
Must have the same shape as reference_positions.</p></li>
<li><p><strong>skin_distance_threshold</strong> (<em>float</em>) – Maximum allowed atomic displacement before neighbor list becomes invalid.
Typically set to (cutoff_radius - cutoff) / 2 for safety.
Units should match the coordinate system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>needs_rebuild</strong> – True if any atom has moved beyond skin distance requiring neighbor list rebuild.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Currently only supports single system.</p></li>
<li><p>Uses GPU acceleration for efficient displacement computation</p></li>
<li><p>Early termination optimization for performance</p></li>
<li><p>Essential for efficient molecular dynamics simulations</p></li>
</ul>
</dd></dl>

</section>
<section id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.estimate_cell_list_sizes">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">estimate_cell_list_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/cell_list.html#estimate_cell_list_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.estimate_cell_list_sizes" title="Link to this definition">#</a></dt>
<dd><p>Estimate allocation sizes for torch.compile-friendly cell list construction.</p>
<p>Provides conservative estimates for maximum memory allocations needed when
building cell lists with fixed-size tensors to avoid dynamic allocation
and graph breaks in torch.compile.</p>
<p>This function is not torch.compile compatible because it returns an integer
recieved from using torch.Tensor.item()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrix defining the simulation box.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Flags indicating periodic boundary conditions in x, y, z directions.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Maximum distance for neighbor search, determines minimum cell size.</p></li>
<li><p><strong>max_nbins</strong> (<em>int</em><em>, </em><em>default=1000</em>) – Maximum number of cells to allocate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>max_total_cells</strong> (<em>int</em>) – Estimated maximum number of cells needed for spatial decomposition.
For degenerate cells, returns the total number of atoms.</p></li>
<li><p><strong>max_atoms_per_cell</strong> (<em>int</em>) – Estimated maximum atoms that could be assigned to any single cell.
Assumes roughly uniform distribution with safety margins.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor, shape (3,), dtype=int32</em>) – Radius of neighboring cells to search in each dimension.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[int, <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Cell size is determined by the cutoff distance to ensure neighboring
cells contain all potential neighbors. The estimation assumes roughly
cubic cells and uniform atomic distribution.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.estimate_max_neighbors">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">estimate_max_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atomic_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.35</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safety_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/neighbor_utils.html#estimate_max_neighbors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.estimate_max_neighbors" title="Link to this definition">#</a></dt>
<dd><p>Estimate maximum neighbors per atom based on volume calculations.</p>
<p>Uses atomic density and cutoff volume to estimate a conservative upper bound
on the number of neighbors any atom could have. This maintains torch.compile
compatibility by using only tensor operations without dynamic control flow.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<em>float</em>) – Maximum distance for considering atoms as neighbors.</p></li>
<li><p><strong>atomic_density</strong> (<em>float</em><em>, </em><em>optional</em>) – Atomic density in atoms per unit volume. Default is 1.0.</p></li>
<li><p><strong>safety_factor</strong> (<em>float</em>) – Safety factor to multiply the estimated number of neighbors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>max_neighbors_estimate</strong> – Conservative estimate of maximum neighbors per atom. Returns 0 for
empty systems, total atom count for degenerate cells.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The estimation uses the formula:
neighbors = safety_factor * density × cutoff_sphere_volume
where density = N_atoms / cell_volume and cutoff_sphere_volume = (4/3)pi r³</p>
<p>The result is rounded up to the multiple of 16 for memory alignment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.estimate_batch_cell_list_sizes">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">estimate_batch_cell_list_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/batch_cell_list.html#estimate_batch_cell_list_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.estimate_batch_cell_list_sizes" title="Link to this definition">#</a></dt>
<dd><p>Estimate memory allocation sizes for batch cell list construction.</p>
<p>Analyzes a batch of systems to determine conservative memory
allocation requirements for torch.compile-friendly batch cell list building.
Uses system sizes, cutoff distance, and safety factors to prevent overflow.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – Unit cell matrices for each system in the batch.</p></li>
<li><p><strong>pbc</strong> (<em>torch.Tensor</em><em>, </em><em>shape</em><em> (</em><em>num_systems</em><em>, </em><em>3</em><em>)</em><em>, </em><em>dtype=bool</em>) – Periodic boundary condition flags for each system and dimension.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Neighbor search cutoff distance.</p></li>
<li><p><strong>max_nbins</strong> (<em>int</em><em>, </em><em>default=1000</em>) – Maximum number of cells to allocate per system.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>max_total_cells_across_batch</strong> (<em>int</em>) – Estimated maximum total cells needed across all systems combined.</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>torch.Tensor, shape (num_systems, 3), dtype=int32</em>) – Radius of neighboring cells to search for each system.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[int, <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Estimates assume roughly uniform atomic distribution within each system</p></li>
<li><p>Cell sizes are determined by the smallest cutoff to ensure neighbor completeness</p></li>
<li><p>For degenerate cells or empty systems, returns conservative fallback values</p></li>
<li><p>Memory usage scales as max_total_cells_across_batch * max_atoms_per_cell_any_system</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nvalchemiops.neighborlist.allocate_cell_list">
<span class="sig-prename descclassname"><span class="pre">nvalchemiops.neighborlist.</span></span><span class="sig-name descname"><span class="pre">allocate_cell_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total_atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_total_cells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_search_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nvalchemiops/neighborlist/neighbor_utils.html#allocate_cell_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nvalchemiops.neighborlist.allocate_cell_list" title="Link to this definition">#</a></dt>
<dd><p>Allocate memory for the cell list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>total_atoms</strong> (<em>int</em>)</p></li>
<li><p><strong>max_total_cells</strong> (<em>int</em>)</p></li>
<li><p><strong>neighbor_search_radius</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">API Reference</p>
      </div>
    </a>
    <a class="right-next"
       href="dispersion.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nvalchemiops.interactions.dispersion</span></code>: Dispersion Corrections</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#high-level-interface">High-Level Interface</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.neighbor_list"><code class="docutils literal notranslate"><span class="pre">neighbor_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#single-system-algorithms">Single System Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.naive_neighbor_list"><code class="docutils literal notranslate"><span class="pre">naive_neighbor_list()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.cell_list"><code class="docutils literal notranslate"><span class="pre">cell_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cell-list-sub-algorithms">Cell List (Sub-)Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.build_cell_list"><code class="docutils literal notranslate"><span class="pre">build_cell_list()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.query_cell_list"><code class="docutils literal notranslate"><span class="pre">query_cell_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#batch-processing-algorithms">Batch Processing Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list"><code class="docutils literal notranslate"><span class="pre">batch_naive_neighbor_list()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.batch_cell_list"><code class="docutils literal notranslate"><span class="pre">batch_cell_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#batch-cell-list-sub-algorithms">Batch Cell List (Sub-)Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.batch_build_cell_list"><code class="docutils literal notranslate"><span class="pre">batch_build_cell_list()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.batch_query_cell_list"><code class="docutils literal notranslate"><span class="pre">batch_query_cell_list()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dual-cutoff-algorithms">Dual Cutoff Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.naive_neighbor_list_dual_cutoff"><code class="docutils literal notranslate"><span class="pre">naive_neighbor_list_dual_cutoff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.batch_naive_neighbor_list_dual_cutoff"><code class="docutils literal notranslate"><span class="pre">batch_naive_neighbor_list_dual_cutoff()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rebuild-detection">Rebuild Detection</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.cell_list_needs_rebuild"><code class="docutils literal notranslate"><span class="pre">cell_list_needs_rebuild()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.neighbor_list_needs_rebuild"><code class="docutils literal notranslate"><span class="pre">neighbor_list_needs_rebuild()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.check_cell_list_rebuild_needed"><code class="docutils literal notranslate"><span class="pre">check_cell_list_rebuild_needed()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.check_neighbor_list_rebuild_needed"><code class="docutils literal notranslate"><span class="pre">check_neighbor_list_rebuild_needed()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#utility-functions">Utility Functions</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.estimate_cell_list_sizes"><code class="docutils literal notranslate"><span class="pre">estimate_cell_list_sizes()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.estimate_max_neighbors"><code class="docutils literal notranslate"><span class="pre">estimate_max_neighbors()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.estimate_batch_cell_list_sizes"><code class="docutils literal notranslate"><span class="pre">estimate_batch_cell_list_sizes()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nvalchemiops.neighborlist.allocate_cell_list"><code class="docutils literal notranslate"><span class="pre">allocate_cell_list()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../_sources/modules/neighborlist.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, NVIDIA.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.2.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>